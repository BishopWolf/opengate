/* --------------------------------------------------
   Copyright (C): OpenGATE Collaboration
   This software is distributed under the terms
   of the GNU Lesser General  Public Licence (LGPL)
   See LICENSE.md for further details
   ------------------------------------ -------------- */

#include "G4EmCalculator.hh"
#include "G4ParticleDefinition.hh"
#include "G4RandomTools.hh"
#include "G4RunManager.hh"
#include "G4Threading.hh"
#include "G4Electron.hh"
#include "GateHelpers.h"
#include "GateHelpersDict.h"
#include "GateHelpersImage.h"
#include "GateMaterialMuHandler.h"
#include "GateTLEDoseActor.h"
#include "GateTLEUserTrackInformation.h"

#include <iostream>
#include <itkAddImageFilter.h>
#include <vector>

G4Mutex SetPixelTLEMutex = G4MUTEX_INITIALIZER;

GateTLEDoseActor::GateTLEDoseActor(py::dict &user_info)
    : GateDoseActor(user_info) {
  fMultiThreadReady = true;
  fEnergyMax = 0;
  fEnergyMin = 0;
}

void GateTLEDoseActor::InitializeUserInfo(py::dict &user_info) {
  GateDoseActor::InitializeUserInfo(user_info);
  fEnergyMin = py::cast<double>(user_info["energy_min"]);
  fEnergyMax = py::cast<double>(user_info["energy_max"]);
  auto database = py::cast<std::string>(user_info["database"]);
  fMaterialMuHandler = GateMaterialMuHandler::GetInstance(database, fEnergyMax);
}



void GateTLEDoseActor::BeginOfEventAction(const G4Event *event) {
  if (fEmCalc ==0){
    fEmCalc = new G4EmCalculator();
  }
  auto &l = fThreadLocalData.Get();
  l.fIsTLESecondary = false;
  l.fSecWhichDeposit.clear();
  GateDoseActor::BeginOfEventAction(event);
}
void GateTLEDoseActor::PreUserTrackingAction(const G4Track *track) {
  G4Event* event = G4EventManager::GetEventManager()->GetNonconstCurrentEvent();
  auto &l = fThreadLocalData.Get();

  // if the particle is a gamma, we associate a map which will associate the
  // gamma TID with the number of secondaries created when the particle is in
  // TLE mode

  if (track->GetDefinition()->GetParticleName() == "gamma") {
    l.fIsTLEGamma = false;
    l.fIsTLESecondary = false;
  }

  // if the particle is not a gamma, we want to associate a secondary boolean to
  // allow or not the energy deposition.
  //- If it's a direct secondary of the gamma with the PID inside, which have to
  // not deposit its energy, the boolean is set to false
  //- If it's a direct secondary, but the number of remaining secondaries to
  // track is 0, it means that this secondary was not created by a TLE gamma,
  // and
  // the boolean is set to false
  //- If it's an indirect secondary, created by a secondary generated by a
  // gamma, we do nothing, since the boolean was already fixed.
  //  If it's a primary or a secondary generated from a primary which is not a
  //  gamma, the boolean is set to False at the beginning of the event

  else {
    if (track->GetUserInformation() != 0){
     GateTLEUserTrackInformation* tleInfo  = dynamic_cast<GateTLEUserTrackInformation*>(track->GetUserInformation());
     std::cout<<tleInfo->GetTLEDoseBool()<<std::endl;
      l.fIsTLESecondary = tleInfo->GetTLEDoseBool();
    }


    //l.fIsTLESecondary = AUserInfo->GetTLEDoseBool();
    //std::cout<<AUserInfo->GetTLEDoseBool()<<std::endl;
   /* auto parent_id = track->GetParentID();
    for (auto it = l.fSecWhichDeposit.begin(); it != l.fSecWhichDeposit.end(); ++it) {
      if (parent_id == it->first) {
        std::vector<G4bool> toTleList = it->second;
        std::cout<<it->second.size()<<std::endl;
        l.fIsTLESecondary = toTleList.back();
        it->second.pop_back();
        if (it->second.size() == 0){
          l.fSecWhichDeposit.erase(parent_id);
          }
        }
      }
      */
    }
  }

void GateTLEDoseActor::SteppingAction(G4Step *step) {
  auto &l = fThreadLocalData.Get();
  G4double range_lim = 2 * CLHEP::mm;
  const auto pre_step = step->GetPreStepPoint();

  double energy = 0;
  energy = pre_step->GetKineticEnergy();
  const G4Material* currentMat = pre_step->GetMaterial();
  auto nbSec = step->GetSecondaryInCurrentStep()->size();
  if (step->GetTrack()->GetDefinition()->GetParticleName() == "gamma") {
    
    G4double csda = fEmCalc->GetCSDARange(energy,G4Electron::Definition(),currentMat);
    // For too high energy, no TLE
    if (csda > range_lim) {
      //std::cout<<nbSec<<"   1"<<std::endl;
      l.fIsTLEGamma = false;
      if (nbSec > 0) {
        for (auto i=0; i< nbSec; i++){
            GateTLEUserTrackInformation* userInfo =new GateTLEUserTrackInformation();
            userInfo->SetTLEDoseBool(false);
            auto* secs = step->GetfSecondary();
            auto* sec = (*secs)[secs->size() -i -1];
            sec->SetUserInformation(userInfo);
          }
        }
      return GateDoseActor::SteppingAction(step);
    } 
    else {
      //std::cout<<nbSec<<"   2"<<std::endl;
      l.fIsTLEGamma = true;
       if (nbSec > 0) {
        for (auto i=0; i< nbSec; i++){
          GateTLEUserTrackInformation* userInfo=new GateTLEUserTrackInformation();
          userInfo->SetTLEDoseBool(true);
          auto* secs = step->GetfSecondary();
          auto* sec = (*secs)[secs->size() -i -1];
          sec->SetUserInformation(userInfo);
        }
        
      }
    }
  
  }

  // For non-gamma particle, no TLE
  if (step->GetTrack()->GetDefinition()->GetParticleName() != "gamma") {
    if (l.fIsTLESecondary == true) {
      return;
    }
    return GateDoseActor::SteppingAction(step);
  }

  auto weight = step->GetTrack()->GetWeight();
  auto step_length = step->GetStepLength();
  auto density = pre_step->GetMaterial()->GetDensity();
  auto mu_en_over_rho = fMaterialMuHandler->GetMuEnOverRho(
      pre_step->GetMaterialCutsCouple(), energy);
  // (0.1 because length is in mm -> cm)
  auto edep = weight * 0.1 * energy * mu_en_over_rho * step_length * density /
              (CLHEP::g / CLHEP::cm3);

  // Kill photon below a given energy
  if (energy <= fEnergyMin) {
    edep = energy;
    step->GetTrack()->SetTrackStatus(fStopAndKill);
  }
  const double dose = edep / density;

  // Get the voxel index and check if the step was within the 3D image
  G4ThreeVector position;
  bool isInside;
  Image3DType::IndexType index;
  GetVoxelPosition(step, position, isInside, index);
  const auto event_id =
      G4RunManager::GetRunManager()->GetCurrentEvent()->GetEventID();
  if (isInside) {
    G4AutoLock mutex(&SetPixelTLEMutex); // mutex is bound to the if-scope
    if (fDoseFlag) {
      ImageAddValue<Image3DType>(cpp_dose_image, index, dose);
    }
    ImageAddValue<Image3DType>(cpp_edep_image, index, edep);

    if (fEdepSquaredFlag || fDoseSquaredFlag) {
      if (fEdepSquaredFlag) {
        ScoreSquaredValue(fThreadLocalDataEdep.Get(), cpp_edep_squared_image,
                          edep, event_id, index);
      }
      if (fDoseSquaredFlag) {
        ScoreSquaredValue(fThreadLocalDataDose.Get(), cpp_dose_squared_image,
                          dose, event_id, index);
      }
    }
  }
}
